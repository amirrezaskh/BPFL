#!/usr/bin/env python3
"""
BPFL Documentation Commit and Push Script
Safely commits and pushes README.md files to all experimental branches
"""

import subprocess
import sys
from typing import List, Tuple

def run_git_command(command: List[str], capture_output: bool = True) -> Tuple[bool, str]:
    """Run a git command and return success status and output"""
    try:
        result = subprocess.run(command, capture_output=capture_output, text=True, timeout=30)
        return result.returncode == 0, result.stdout.strip()
    except subprocess.TimeoutExpired:
        return False, "Command timed out"
    except Exception as e:
        return False, str(e)

def get_experimental_branches() -> List[str]:
    """Get list of experimental branches"""
    success, output = run_git_command(['git', 'branch', '-r'])
    if not success:
        return []
    
    branches = []
    for line in output.split('\n'):
        branch = line.strip().replace('origin/', '')
        if branch and 'HEAD' not in branch and branch not in ['main', 'Centralized']:
            branches.append(branch)
    return branches

def check_branch_status(branch: str) -> dict:
    """Check the status of a branch"""
    # Switch to branch
    success, _ = run_git_command(['git', 'checkout', branch])
    if not success:
        return {'error': 'checkout_failed'}
    
    # Check if README exists
    try:
        with open('README.md', 'r') as f:
            readme_content = f.read()
        if len(readme_content) < 100:  # Basic validation
            return {'error': 'readme_too_short'}
    except FileNotFoundError:
        return {'error': 'no_readme'}
    
    # Check git status
    success, status_output = run_git_command(['git', 'status', '--porcelain'])
    if not success:
        return {'error': 'status_check_failed'}
    
    has_changes = 'README.md' in status_output
    return {'has_changes': has_changes, 'status': 'ready'}

def commit_and_push_branch(branch: str) -> dict:
    """Commit and push documentation for a specific branch"""
    print(f"📝 Processing: {branch}")
    
    # Check branch status
    status = check_branch_status(branch)
    if 'error' in status:
        return {'success': False, 'error': status['error']}
    
    if not status.get('has_changes'):
        return {'success': True, 'message': 'no_changes'}
    
    # Stage README.md
    success, _ = run_git_command(['git', 'add', 'README.md'])
    if not success:
        return {'success': False, 'error': 'add_failed'}
    
    # Commit changes
    commit_msg = """Add experiment-specific documentation

- Comprehensive experiment configuration details
- Dataset and architecture specifications  
- Data distribution analysis
- Running instructions and expected results
- Cross-references to related experiments

Generated by automated documentation system."""
    
    success, _ = run_git_command(['git', 'commit', '-m', commit_msg])
    if not success:
        return {'success': False, 'error': 'commit_failed'}
    
    print(f"✅ Committed: {branch}")
    
    # Push to origin
    success, output = run_git_command(['git', 'push', 'origin', branch])
    if not success:
        return {'success': False, 'error': 'push_failed', 'details': output}
    
    print(f"🚀 Pushed: {branch}")
    return {'success': True, 'message': 'completed'}

def main():
    """Main function"""
    print("🚀 BPFL Documentation Commit & Push Script")
    print("==========================================")
    
    # Get current branch
    success, original_branch = run_git_command(['git', 'branch', '--show-current'])
    if not success:
        print("❌ Could not determine current branch")
        sys.exit(1)
    
    print(f"📍 Current branch: {original_branch}")
    
    # Get experimental branches
    branches = get_experimental_branches()
    if not branches:
        print("❌ No experimental branches found")
        sys.exit(1)
    
    print(f"📝 Found {len(branches)} experimental branches")
    
    # Show preview of first few branches
    print(f"\nBranches to process:")
    for i, branch in enumerate(branches[:5]):
        print(f"   {i+1}. {branch}")
    if len(branches) > 5:
        print(f"   ... and {len(branches) - 5} more")
    
    # Confirm
    response = input(f"\nCommit and push README.md to all {len(branches)} branches? (y/n): ")
    if response.lower() != 'y':
        print("❌ Operation cancelled")
        return
    
    print(f"\n🔄 Processing {len(branches)} branches...")
    
    # Process each branch
    results = {
        'success': [],
        'no_changes': [],
        'errors': []
    }
    
    for i, branch in enumerate(branches, 1):
        print(f"\n[{i}/{len(branches)}] {branch}")
        
        result = commit_and_push_branch(branch)
        
        if result['success']:
            if result['message'] == 'no_changes':
                results['no_changes'].append(branch)
                print(f"ℹ️  No changes: {branch}")
            else:
                results['success'].append(branch)
                print(f"✅ Completed: {branch}")
        else:
            results['errors'].append((branch, result['error']))
            error_msg = result.get('details', result['error'])
            print(f"❌ Failed: {branch} ({error_msg})")
    
    # Return to original branch
    print(f"\n🔄 Returning to: {original_branch}")
    run_git_command(['git', 'checkout', original_branch])
    
    # Final summary
    print(f"\n🎉 Documentation process complete!")
    print(f"=" * 40)
    print(f"✅ Successfully processed: {len(results['success'])} branches")
    print(f"ℹ️  No changes needed: {len(results['no_changes'])} branches")
    print(f"❌ Errors encountered: {len(results['errors'])} branches")
    
    if results['errors']:
        print(f"\n❌ Failed branches:")
        for branch, error in results['errors']:
            print(f"   - {branch}: {error}")
    
    if results['success']:
        print(f"\n✅ Successfully documented branches:")
        for branch in results['success'][:10]:  # Show first 10
            print(f"   - {branch}")
        if len(results['success']) > 10:
            print(f"   ... and {len(results['success']) - 10} more")
    
    print(f"\n📊 Your BPFL research framework documentation is now distributed across all experimental branches!")
    print(f"🔗 Each branch contains experiment-specific documentation for reproducible research.")

if __name__ == "__main__":
    main()
